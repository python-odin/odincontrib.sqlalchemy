import inspect
import odin

from odin import registration, Mapping
from odin.fields.base import BaseField
from odin.mapping import FieldResolverBase, mapping_factory
from odin.resources import ResourceBase
from sqlalchemy import types as sql_types, Column, Table

# Typing imports
from typing import Union, Any, Type, Tuple, Sequence, Dict, TypeVar  # noqa

try:
    from odin.fields import future
except ImportError:
    future = None


ResourceType = Type[ResourceBase]


class SqlAlchemyFieldResolver(FieldResolverBase):
    """
    Field resolver for SQLAlchemy declarative Models
    """
    def get_field_dict(self):
        # type: () -> Dict[str, Column]
        return {col.name: col for col in self.obj.__table__.columns}


def register_model_base(base):
    # type: (Any) -> None
    """
    Register a model base class with the Odin field resolver.

    :param base: Base class generated by :py:meth:`sqlalchemy.ext.declarative.declarative_base`

    """
    if not hasattr(base, 'metadata'):
        raise TypeError("base does not appear to be a valid SQL Alchemy table base.")

    registration.register_field_resolver(SqlAlchemyFieldResolver, base)


SQL_TYPE_MAP = {
    sql_types.String: (odin.StringField, {
        'max_length': (None, 'length'),
    }),
    sql_types.Text: (odin.StringField, {}),
    sql_types.Integer: (odin.IntegerField, {}),
    sql_types.Numeric: (odin.FloatField, {}),
    sql_types.Boolean: (odin.BooleanField, {}),
    sql_types.Date: (odin.DateField, {}),
    sql_types.Time: (odin.TimeField, {}),
    sql_types.DateTime: (odin.DateTimeField, {}),
}

if future:
    SQL_TYPE_MAP[sql_types.Enum] = (
        future.EnumField, {
            'enum': (None, 'enum_class'),
        }
    )


def field_factory(column):
    # type: (Column) -> BaseField
    """
    Generate an equivalent resource field from a SQLAlchemy column definition.
    """
    col_type = column.type
    mapping = SQL_TYPE_MAP.get(col_type.__class__, None)
    if mapping:
        field, attr_map = mapping
        field_kwargs = {
            'null': column.nullable,
            'key': column.primary_key,
        }

        # Map attributes
        for dest, (transform, source) in attr_map.items():
            value = getattr(col_type, source, None)
            if value:
                if transform:
                    value = transform(value, col_type)
                field_kwargs[dest] = value

        return field(**field_kwargs)


class ModelResource(odin.Resource):
    """
    Resource with some extra model specific fields.
    """
    def to_model(self):
        """
        Map this resource to corresponding model.
        """
        mapping = registration.get_mapping(self.__class__, self.__model__)
        return mapping.apply(self)


R = TypeVar('R')


def table_resource_factory(table, module=None, base_resource=ModelResource, resource_mixins=None, exclude_fields=None,
                           generate_mappings=False, return_mappings=False, additional_fields=None,
                           resource_type_name=None, reverse_exclude_fields=None):
    # type: (Any, Union[str, module], R, Sequence[ResourceType], Sequence[str], bool, bool, Dict[str, BaseField], str, Sequence[str]) -> Union[R, Tuple[R, Mapping, Mapping]]
    """
    Generate an Odin Resource from a SQLAlchemy Table.

    :param table: SQLAlchemy Table or Declarative object
    :param module: Module name of table (this is estimated if not provided)
    :param base_resource: Resource to use as a base class
    :param resource_mixins: Any mixins to apply in the resource tree.
    :param exclude_fields: List of field names to exclude
    :param generate_mappings: Should mappings between the model and resource be created.
    :param return_mappings: Return the mappings along with Resource
    :param additional_fields: Additional fields to add to the resource
    :param resource_type_name: Typename of the resource. This defaults to type name of the table
    :param reverse_exclude_fields:
    :return:

    """
    model = None
    if not isinstance(table, Table):
        if hasattr(table, '__table__') and isinstance(table.__table__, Table):
            model = table
            table = table.__table__
            table_name = model.__name__
        else:
            raise TypeError("table is not a Table instance")
    else:
        table_name = str(table.name)
        if generate_mappings or return_mappings:
            raise ValueError("Mappings can only be generated for declarative tables.")

    # Determine the calling module
    if module is None:
        frame = inspect.stack()[1]
        module = inspect.getmodule(frame[0]).__name__
    elif not isinstance(module, str):
        module = module.__name__

    # Set defaults
    resource_mixins = resource_mixins or []
    bases = tuple(resource_mixins + [base_resource])
    exclude_fields = exclude_fields or []
    generate_mappings = generate_mappings or return_mappings  # Need to be generated if expected to be returned
    resource_type_name = resource_type_name or table_name
    reverse_exclude_fields = reverse_exclude_fields or []

    attrs = {
        '__module__': module,
        '__table__': table,
        '__model__': model,
    }

    # Map columns to fields
    for col in table.columns:
        if col.name in exclude_fields:
            continue

        field = field_factory(col)
        if field:
            attrs[col.name] = field

    # Add any additional fields.
    if additional_fields:
        attrs.update(additional_fields)

    # Create
    resource_type = type(resource_type_name, bases, attrs)  # type: ResourceType

    # Generate mappings
    if generate_mappings:
        forward_mapping, reverse_mapping = mapping_factory(
            model, resource_type, reverse_exclude_fields=reverse_exclude_fields
        )
        if return_mappings:
            return resource_type, forward_mapping, reverse_mapping

    return resource_type
