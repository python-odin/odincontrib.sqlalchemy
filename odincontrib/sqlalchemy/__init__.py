import inspect
import odin

from odin import registration, Mapping, NotProvided
from odin.fields.base import BaseField
from odin.mapping import FieldResolverBase, mapping_factory
from odin.resources import ResourceBase
from sqlalchemy import types as sql_types, Column, Table

# Typing imports
from typing import Union, Any, Type, Tuple, Sequence, Dict, TypeVar  # noqa

try:
    from odin.fields import future
except ImportError:
    future = None


ResourceType = Type[ResourceBase]


class SqlAlchemyFieldResolver(FieldResolverBase):
    """
    Field resolver for SQLAlchemy declarative Models
    """
    def get_field_dict(self):
        # type: () -> Dict[str, Column]
        return {col.name: col for col in self.obj.__table__.columns}


def register_model_base(base):
    # type: (Any) -> None
    """
    Register a model base class with the Odin field resolver.

    :param base: Base class generated by :py:meth:`sqlalchemy.ext.declarative.declarative_base`

    """
    if not hasattr(base, 'metadata'):
        raise TypeError("base does not appear to be a valid SQL Alchemy table base.")

    registration.register_field_resolver(SqlAlchemyFieldResolver, base)


def column_attr(attr, default=None):
    """Get value from Column instance"""
    def transform(column):
        return getattr(column, attr, default)
    return transform


def type_attr(attr, default=None):
    """Get value from Column type instance"""
    def transform(column):
        return getattr(column.type, attr, default)
    return transform


SQL_TYPE_MAP = {
    sql_types.String: (odin.StringField, {
        'max_length': type_attr('length'),
    }),
    sql_types.Text: (odin.StringField, {}),
    sql_types.Integer: (odin.IntegerField, {}),
    sql_types.Float: (odin.FloatField, {}),
    sql_types.Numeric: (odin.FloatField, {}),
    sql_types.Boolean: (odin.BooleanField, {}),
    sql_types.Date: (odin.DateField, {}),
    sql_types.Time: (odin.TimeField, {}),
    sql_types.DateTime: (odin.DateTimeField, {}),
}

if future:
    SQL_TYPE_MAP[sql_types.Enum] = (
        future.EnumField, {
            'enum': type_attr('enum_class'),
        }
    )


def field_factory(column):
    # type: (Column) -> BaseField
    """
    Generate an equivalent resource field from a SQLAlchemy column definition.
    """
    col_type = column.type
    mapping = SQL_TYPE_MAP.get(col_type.__class__, None)
    if mapping:
        field, field_attr_map = mapping

        attr_map = {
            'null': column_attr('nullable'),
            'key': column_attr('primary_key', False),
            'default': lambda c: c.default.arg if c.default else NotProvided,
            'doc_text': column_attr('doc'),
        }
        attr_map.update(field_attr_map)

        # Map attributes
        field_kwargs = {}
        for dest, transform in attr_map.items():
            field_kwargs[dest] = transform(column)

        return field(**field_kwargs)


class ModelResource(odin.Resource):
    """
    Resource with some extra model specific fields.
    """
    def to_model(self):
        """
        Map this resource to corresponding model.
        """
        mapping = registration.get_mapping(self.__class__, self.__model__)
        return mapping.apply(self)


R = TypeVar('R')


def table_resource_factory(table, module=None, base_resource=ModelResource, resource_mixins=None, exclude_fields=None,
                           generate_mappings=False, return_mappings=False, additional_fields=None,
                           resource_type_name=None, reverse_exclude_fields=None):
    # type: (Any, Union[str, module], R, Sequence[ResourceType], Sequence[str], bool, bool, Dict[str, BaseField], str, Sequence[str]) -> Union[R, Tuple[R, Mapping, Mapping]]
    """
    Generate an Odin Resource from a SQLAlchemy Table.

    :param table: SQLAlchemy Table or Declarative object
    :param module: Module name of table (this is estimated if not provided)
    :param base_resource: Resource to use as a base class
    :param resource_mixins: Any mixins to apply in the resource tree.
    :param exclude_fields: List of field names to exclude
    :param generate_mappings: Should mappings between the model and resource be created.
    :param return_mappings: Return the mappings along with Resource
    :param additional_fields: Additional fields to add to the resource
    :param resource_type_name: Typename of the resource. This defaults to type name of the table
    :param reverse_exclude_fields:
    :return:

    """
    model = None
    if not isinstance(table, Table):
        if hasattr(table, '__table__') and isinstance(table.__table__, Table):
            model = table
            table = table.__table__
            table_name = model.__name__
        else:
            raise TypeError("table is not a Table instance")
    else:
        table_name = str(table.name)
        if generate_mappings or return_mappings:
            raise ValueError("Mappings can only be generated for declarative tables.")

    # Determine the calling module
    if module is None:
        frame = inspect.stack()[1]
        module = inspect.getmodule(frame[0]).__name__
    elif not isinstance(module, str):
        module = module.__name__

    # Set defaults
    resource_mixins = resource_mixins or []
    bases = tuple(resource_mixins + [base_resource])
    exclude_fields = exclude_fields or []
    generate_mappings = generate_mappings or return_mappings  # Need to be generated if expected to be returned
    resource_type_name = resource_type_name or table_name
    reverse_exclude_fields = reverse_exclude_fields or []

    attrs = {
        '__module__': module,
        '__table__': table,
        '__model__': model,
    }

    # Map columns to fields
    for col in table.columns:
        if col.name in exclude_fields:
            continue

        field = field_factory(col)
        if field:
            attrs[col.name] = field

    # Add any additional fields.
    if additional_fields:
        attrs.update(additional_fields)

    # Create
    resource_type = type(resource_type_name, bases, attrs)  # type: ResourceType

    # Generate mappings
    if generate_mappings:
        forward_mapping, reverse_mapping = mapping_factory(
            model, resource_type, reverse_exclude_fields=reverse_exclude_fields
        )
        if return_mappings:
            return resource_type, forward_mapping, reverse_mapping

    return resource_type
